// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@chainlink/contracts/src/v0.6/VRFConsumerBase.sol";
import "./LuckBox.sol";

// import "./interfaces/ILuckbox.sol";

/**
 * @title Factory for creating new luckbox contract.
 */

contract Factory is VRFConsumerBase, ReentrancyGuard, Ownable {
  using SafeERC20 for IERC20;

  struct Box {
    string name;
    string symbol;
    address owner;
    address contractAddress;
    bool banned;
    bool approved;
  }

  Box[] public boxes;
  uint256 public totalBoxes;

  // Nonce to be generated by Chainlink VRF
  uint256 public randomNonce;
  mapping(bytes32 => address) private requestIdToAddress;

  // Fee section
  address public devAddr;
  uint256 public feePercent = 300; // 3%
  uint256 public constant MAX_FEE = 1000; // 10%

  uint256 public COOLDOWN = 3 seconds;
  uint256 public timestamp;

  // Chainlink constants on Polygon
  address public constant VRF_COORDINATOR =
    0x3d2341ADb2D31f1c5530cDC622016af293177AE0;
  address public constant LINK_TOKEN =
    0xb0897686c545045aFc77CF20eC7A532E3120E0F1;
  bytes32 public constant KEY_HASH =
    0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da;
  uint256 public constant FEE = 100000000000000; // 0.0001 LINK

  event LuckboxCreated(address indexed _address);
  event SetFee(uint256 _fee);
  event SetDevAddr(address _devAddr);
  event RequestedNonce(address user, uint256 timestamp);

  constructor(address _devAddr)
    public
    VRFConsumerBase(VRF_COORDINATOR, LINK_TOKEN)
  {
    require(_devAddr != address(0), "Address is zero");
    devAddr = _devAddr;
  }

  function createLuckbox(
    string calldata name,
    string calldata symbol,
    uint256 ticketPrice
  ) external nonReentrant {
    LuckBox luckbox = new LuckBox(name, symbol, ticketPrice, address(this));

    luckbox.transferOwnership(msg.sender);

    address newLuckbox = (address(luckbox));

    boxes.push(
      Box({
        name: name,
        symbol: symbol,
        owner: msg.sender,
        contractAddress: newLuckbox,
        banned: false,
        approved: false
      })
    );

    totalBoxes += 1;

    timestamp = block.timestamp;

    emit LuckboxCreated(newLuckbox);
  }

  // request a new nonce from Chainlink VRF
  function requestNonce() public nonReentrant {
    require(
      IERC20(LINK_TOKEN).balanceOf(address(this)) >= FEE,
      "Insufficient LINK to proceed VRF"
    );
    require(
      block.timestamp >= timestamp + COOLDOWN,
      "Still in cooldown period"
    );

    bytes32 requestId = requestRandomness(KEY_HASH, FEE);
    requestIdToAddress[requestId] = msg.sender;

    emit RequestedNonce(msg.sender, block.timestamp);
  }

  function totalLink() public view returns (uint256) {
    return IERC20(LINK_TOKEN).balanceOf(address(this));
  }

  function getBoxOwner(uint256 _id) public view returns (address) {
    return boxes[_id].owner;
  }

  function getBoxContractAddress(uint256 _id) public view returns (address) {
    return boxes[_id].contractAddress;
  }

  function getBoxName(uint256 _id) public view returns (string memory) {
    return boxes[_id].name;
  }

  function getBoxSymbol(uint256 _id) public view returns (string memory) {
    return boxes[_id].symbol;
  }

  function isBanned(uint256 _id) public view returns (bool) {
    return boxes[_id].banned;
  }

  function isApproved(uint256 _id) public view returns (bool) {
    return boxes[_id].approved;
  }

  // ADMIN FUNCTIONS
  function setDevAddr(address _devAddr) public onlyOwner nonReentrant {
    require(_devAddr != address(0), "Address zero !");
    devAddr = _devAddr;

    emit SetDevAddr(devAddr);
  }

  function setFee(uint256 _feePercent) public onlyOwner nonReentrant {
    require(_feePercent <= MAX_FEE, "Below MAX_FEE Please");
    feePercent = _feePercent;

    emit SetFee(feePercent);
  }

  function setBan(uint256 _id, bool _isBan) public onlyOwner nonReentrant {
    boxes[_id].banned = _isBan;
  }

  function setApprove(uint256 _id, bool _isApprove)
    public
    onlyOwner
    nonReentrant
  {
    boxes[_id].approved = _isApprove;
  }

  function withdrawLink(uint256 _amount) public onlyOwner nonReentrant {
    IERC20(LINK_TOKEN).safeTransfer(msg.sender, _amount);
  }

  // for maintenance purpose
  function forceNonceUpdate(uint256 _nonce) public onlyOwner nonReentrant {
    randomNonce = _nonce;
  }

  // PRIVATE FUNCTIONS

  // callback from Chainlink VRF
  function fulfillRandomness(bytes32 requestId, uint256 _randomness)
    internal
    override
  {
    randomNonce = _randomness;
  }
}
